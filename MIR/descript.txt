macd: RSI :Impulse macd

pandas>=1.3.0
numpy>=1.21.0
scipy>=1.7.0
matplotlib>=3.4.0
requests>=2.26.0
websocket-client>=1.0.0
pytz>=2021.1



graph TD
    A[Start System] --> B[Load Configuration]
    B --> C{Validate Config}
    C -->|Invalid| D[Exit with Error]
    C -->|Valid| E[Parse Arguments]
    E --> F{Select Mode}
    
    F -->|Live Trading| G[Initialize WebSocket Client]
    G --> H[Connect to Dhan API]
    H --> I[Subscribe to Nifty50]
    I --> J[Receive Tick Data]
    J --> K[Buffer Ticks]
    K --> L[Create Minute Candles]
    L --> M{Enough Data?}
    M -->|No| J
    M -->|Yes| N[Calculate Indicators]
    N --> O[Generate Weighted Signal]
    O --> P[Calculate Accuracy Metrics]
    P --> Q[Predict Signal Duration]
    Q --> R{Alert Conditions Met?}
    R -->|No| J
    R -->|Yes| S[Format Alert Message]
    S --> T[Generate Chart]
    T --> U[Send to Telegram]
    U --> V[Update History]
    V --> J
    
    F -->|Backtest| W[Fetch Historical Data]
    W --> X[Run Backtest Engine]
    X --> Y[Generate Report]
    Y --> Z[Save Results]
    
    F -->|Fetch Data| AA[Download Historical Data]
    AA --> AB[Save to CSV]
    AB --> AC[Display Summary]


File Hierarchy

trading-system/
├── config.py                 # Configuration settings
├── logging_setup.py         # Logging configuration
├── main.py                  # Main entry point
├── technical_indicators.py  # Indicators & signal generation
├── chart_utils.py          # Charting utilities
├── dhan_ws_client.py       # WebSocket client
├── telegram_bot.py         # Telegram notifications
├── historical_data.py      # Historical data fetcher
├── backtest_engine.py      # Backtesting engine
├── logs/                   # Log files directory
│   └── trading_system.log
├── images/                 # Generated charts
│   └── analysis_chart.png
└── requirements.txt        # Python dependencies

Usage Examples
1. Initial Setup and Configuration
Setting Up Environment Variables
bash


# Linux/Mac
export DHAN_TOKEN_B64="<your_base64_encoded_dhan_token>"
export DHAN_CLIENT_B64="<your_base64_encoded_client_id>"
export TELEGRAM_TOKEN_B64="<your_base64_encoded_bot_token>"
export TELEGRAM_CHAT_ID="<your_telegram_chat_id>"

# Windows
set DHAN_TOKEN_B64=<your_base64_encoded_dhan_token>
set DHAN_CLIENT_B64=<your_base64_encoded_client_id>
set TELEGRAM_TOKEN_B64=<your_base64_encoded_bot_token>
set TELEGRAM_CHAT_ID=<your_telegram_chat_id>
Creating Base64 Encoded Credentials
python


import base64

# Encode your credentials
dhan_token = "your_actual_dhan_token"
dhan_client = "your_actual_client_id"
telegram_token = "your_telegram_bot_token"

# Generate base64 strings
print(f"DHAN_TOKEN_B64={base64.b64encode(dhan_token.encode()).decode()}")
print(f"DHAN_CLIENT_B64={base64.b64encode(dhan_client.encode()).decode()}")
print(f"TELEGRAM_TOKEN_B64={base64.b64encode(telegram_token.encode()).decode()}")
Installing Dependencies
bash


# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install requirements
pip install pandas numpy matplotlib websocket-client requests scipy pytz
2. Live Trading Mode Examples
Basic Live Trading
bash


# Start live monitoring with default settings
python main.py --mode live
Expected Output:
text


============================================================
    NIFTY50 TRADING SYSTEM
    Mode: LIVE
    Time: 2025-08-23 09:15:00
============================================================
2025-08-23 09:15:01 - root - INFO - Logging initialized - Log file: logs/trading_system.log
2025-08-23 09:15:01 - root - INFO - Configuration validation successful
2025-08-23 09:15:02 - dhan_ws_client - INFO - WebSocket connection established
2025-08-23 09:15:02 - dhan_ws_client - INFO - Subscribed to Nifty50 (ID: 13)
2025-08-23 09:15:03 - telegram_bot - INFO - Telegram message sent successfully
Live Trading with Custom Configuration
python


# custom_config.py
import config

# Override default settings
config.COOLDOWN_SECONDS = 120  # 2 minutes between alerts
config.MIN_DATA_POINTS = 30    # Need 30 candles minimum
config.BUY_THRESHOLD = 0.70    # Stronger signal requirement

# Adjust indicator weights
config.INDICATOR_WEIGHTS = {
    "macd": 0.30,      # Increase MACD weight
    "rsi": 0.25,       # Increase RSI weight
    "vwap": 0.15,
    "keltner": 0.10,
    "supertrend": 0.15,
    "impulse": 0.05
}

# Run with custom config
if __name__ == "__main__":
    from main import run_live_trading
    run_live_trading()
3. Backtesting Examples
Basic Backtest on Recent Data
bash


# Backtest last 7 days of minute data
python main.py --mode backtest \
    --from-date 2025-08-16 \
    --to-date 2025-08-23 \
    --timeframe minute \
    --initial-capital 1000000
Expected Output:
text


Fetching historical data from 2025-08-16 to 2025-08-23...
Retrieved 2340 candles
Date range: 2025-08-16 09:15:00 to 2025-08-23 15:30:00

Running backtest...

============================================================
BACKTEST RESULTS
============================================================
Initial Capital: ₹1,000,000.00
Final Capital: ₹1,045,230.50
Total Return: 4.52%
Sharpe Ratio: 1.85
Max Drawdown: -2.34%
Win Rate: 62.5%
Total Trades: 48
Profitable Trades: 30
Average Win: ₹3,245.60
Average Loss: ₹1,823.40
Best Trade: ₹8,920.30
Worst Trade: -₹4,230.10

============================================================
SIGNAL DURATION PREDICTION ANALYSIS
============================================================
Predictions Analyzed: 48
Overall Accuracy: 73.45%
Average Error: 2.3 candles
High Confidence Accuracy: 85.20%
============================================================

Report saved to: backtest_report.json
Advanced Backtest with Multiple Timeframes
python


# backtest_multiple.py
from datetime import datetime, timedelta
from historical_data import DhanHistoricalData
from backtest_engine import BacktestEngine
import config

def run_multi_timeframe_backtest():
    """Run backtest on multiple timeframes and compare results."""
    
    data_fetcher = DhanHistoricalData(
        config.DHAN_ACCESS_TOKEN_B64,
        config.DHAN_CLIENT_ID_B64
    )
    
    # Define test periods
    test_periods = [
        ("2025-08-01", "2025-08-07", "Week 1"),
        ("2025-08-08", "2025-08-14", "Week 2"),
        ("2025-08-15", "2025-08-21", "Week 3"),
    ]
    
    results_summary = []
    
    for from_date, to_date, period_name in test_periods:
        print(f"\nBacktesting {period_name}: {from_date} to {to_date}")
        
        # Fetch data
        ohlcv_data = data_fetcher.fetch_data_in_chunks(
            from_date, to_date, timeframe="minute"
        )
        
        if ohlcv_data is None:
            print(f"No data for {period_name}")
            continue
        
        # Run backtest
        backtest_engine = BacktestEngine(initial_capital=1000000)
        results = backtest_engine.run_backtest(
            ohlcv_data,
            config.INDICATOR_WEIGHTS,
            config.MIN_DATA_POINTS
        )
        
        # Store results
        results_summary.append({
            "period": period_name,
            "dates": f"{from_date} to {to_date}",
            "total_return": results["total_return_pct"],
            "win_rate": results["win_rate"],
            "sharpe_ratio": results["sharpe_ratio"],
            "max_drawdown": results["max_drawdown"],
            "total_trades": results["total_trades"]
        })
        
        # Print summary
        print(f"Return: {results['total_return_pct']:.2f}%")
        print(f"Win Rate: {results['win_rate']:.1f}%")
        print(f"Trades: {results['total_trades']}")
    
    # Print comparison table
    print("\n" + "="*70)
    print("MULTI-TIMEFRAME BACKTEST COMPARISON")
    print("="*70)
    
    import pandas as pd
    df = pd.DataFrame(results_summary)
    print(df.to_string(index=False))
    
    # Calculate averages
    print("\n" + "-"*70)
    print(f"Average Return: {df['total_return'].mean():.2f}%")
    print(f"Average Win Rate: {df['win_rate'].mean():.1f}%")
    print(f"Average Sharpe: {df['sharpe_ratio'].mean():.2f}")

if __name__ == "__main__":
    run_multi_timeframe_backtest()
4. Historical Data Fetching Examples
Fetch and Save Minute Data
bash


# Fetch minute data for specific date range
python main.py --mode fetch \
    --from-date 2025-08-20 \
    --to-date 2025-08-23 \
    --timeframe minute \
    --security-id 13 \
    --exchange IDX_I
Fetch Daily Data for Analysis
bash


# Fetch daily data for longer period
python main.py --mode fetch \
    --from-date 2025-01-01 \
    --to-date 2025-08-23 \
    --timeframe daily
Custom Data Processing Script
python


# analyze_historical.py
import pandas as pd
from historical_data import DhanHistoricalData
from technical_indicators import TechnicalIndicators, SignalGenerator
import config

def analyze_historical_signals():
    """Analyze historical data for signal patterns."""
    
    # Initialize data fetcher
    fetcher = DhanHistoricalData(
        config.DHAN_ACCESS_TOKEN_B64,
        config.DHAN_CLIENT_ID_B64
    )
    
    # Fetch data
    print("Fetching historical data...")
    data = fetcher.get_intraday_data("2025-08-20", "2025-08-23")
    
    if data is None:
        print("Failed to fetch data")
        return
    
    print(f"Analyzing {len(data)} candles...")
    
    # Initialize signal generator
    signal_gen = SignalGenerator()
    
    # Storage for analysis
    signal_history = []
    
    # Analyze in rolling windows
    window_size = 50
    
    for i in range(window_size, len(data)):
        window_data = data.iloc[i-window_size:i]
        
        # Extract price and volume series
        prices = pd.Series(window_data['close'].values, index=window_data.index)
        volumes = pd.Series(window_data['volume'].values, index=window_data.index)
        highs = pd.Series(window_data['high'].values, index=window_data.index)
        lows = pd.Series(window_data['low'].values, index=window_data.index)
        
        # Calculate indicators
        indicators = {
            "macd": TechnicalIndicators.calculate_macd(prices),
            "rsi": TechnicalIndicators.calculate_rsi(prices),
            "vwap": TechnicalIndicators.calculate_vwap(prices, volumes),
            "keltner": TechnicalIndicators.calculate_keltner_channels(prices, highs, lows),
            "supertrend": TechnicalIndicators.calculate_supertrend(prices, highs, lows),
            "impulse": TechnicalIndicators.calculate_impulse_macd(prices)
        }
        
        # Generate signal with metrics
        signal_result = signal_gen.calculate_weighted_signal_with_metrics(
            indicators,
            config.INDICATOR_WEIGHTS,
            window_data,
            prices.iloc[-1]
        )
        
        # Store result
        signal_history.append({
            'timestamp': window_data.index[-1],
            'price': prices.iloc[-1],
            'signal': signal_result['composite_signal'],
            'score': signal_result['weighted_score'],
            'confidence': signal_result['confidence'],
            'accuracy': signal_result['accuracy_metrics']['signal_accuracy'],
            'duration_est': signal_result['duration_prediction']['estimated_minutes']
        })
    
    # Convert to DataFrame for analysis
    signals_df = pd.DataFrame(signal_history)
    
    # Print analysis
    print("\n" + "="*60)
    print("SIGNAL ANALYSIS SUMMARY")
    print("="*60)
    
    # Signal distribution
    print("\nSignal Distribution:")
    print(signals_df['signal'].value_counts())
    
    # Average metrics by signal type
    print("\nAverage Metrics by Signal Type:")
    grouped = signals_df.groupby('signal').agg({
        'confidence': 'mean',
        'accuracy': 'mean',
        'duration_est': 'mean'
    })
    print(grouped)
    
    # Find high-confidence signals
    high_conf = signals_df[signals_df['confidence'] > 75]
    print(f"\nHigh Confidence Signals (>75%): {len(high_conf)}")
    
    if len(high_conf) > 0:
        print("\nTop 5 High Confidence Signals:")
        print(high_conf.nlargest(5, 'confidence')[['timestamp', 'signal', 'confidence', 'accuracy']])
    
    # Save to CSV
    output_file = "signal_analysis.csv"
    signals_df.to_csv(output_file, index=False)
    print(f"\nDetailed results saved to: {output_file}")

if __name__ == "__main__":
    analyze_historical_signals()
5. Real-time Alert Examples
Sample Alert Message (Telegram)
text


🚀💚 STRONG_BUY Signal 🚀💚
━━━━━━━━━━━━━━━━━━━━━
📍 Price: ₹24,567.85
🎯 Action: BUY
💯 Confidence: 82.5%
📊 Score: 0.825

⏱️ Signal Duration Prediction:
• Expected Hold: 12 minutes
• Candles: 12 candles
• Confidence: HIGH
• Strength Trend: Strengthening

📍 Key Levels:
• Resistance: ₹24,625.00
• Support: ₹24,485.00
• Pivot: ₹24,555.00

📈 Indicator Analysis:
• MACD: 12.45 | Signal: 8.32 (bullish) (Momentum: ↑)
• RSI: 58.3 (bullish) (Momentum: ↑)
• VWAP: ₹24,552.30 | Dev: 0.6% (bullish)
• Keltner: above_middle (bullish)
• Supertrend: bullish (buy)
• Impulse: bullish (strong_buy)

━━━━━━━━━━━━━━━━━━━━━
🕐 Time: 10:45:30 IST
📅 Date: 23-08-2025
6. Testing Individual Components
Test Technical Indicators
python


# test_indicators.py
import pandas as pd
import numpy as np
from technical_indicators import TechnicalIndicators

def test_indicators():
    """Test individual technical indicators."""
    
    # Create sample data
    np.random.seed(42)
    dates = pd.date_range(start='2025-08-23 09:00', periods=100, freq='1min')
    
    # Simulate price movement
    base_price = 24500
    trend = np.linspace(0, 100, 100)
    noise = np.random.normal(0, 20, 100)
    prices = pd.Series(base_price + trend + noise, index=dates)
    
    # Add some structure
    prices = prices.rolling(window=3).mean().fillna(method='bfill')
    
    # Create OHLC data
    high = prices * 1.002
    low = prices * 0.998
    volume = pd.Series(np.random.randint(1000, 10000, 100), index=dates)
    
    print("Testing Technical Indicators")
    print("="*50)
    
    # Test MACD
    print("\n1. MACD:")
    macd_result = TechnicalIndicators.calculate_macd(prices)
    if macd_result:
        print(f"   MACD: {macd_result['macd']:.2f}")
        print(f"   Signal: {macd_result['signal']:.2f}")
        print(f"   Histogram: {macd_result['histogram']:.2f}")
        print(f"   Crossover: {macd_result.get('crossover', 'None')}")
    
    # Test RSI
    print("\n2. RSI:")
    rsi_result = TechnicalIndicators.calculate_rsi(prices)
    print(f"   RSI Value: {rsi_result['rsi']:.1f}")
    print(f"   Signal: {rsi_result['signal']}")
    
    # Test VWAP
    print("\n3. VWAP:")
    vwap_result = TechnicalIndicators.calculate_vwap(prices, volume)
    print(f"   VWAP: ₹{vwap_result['vwap']:.2f}")
    print(f"   Current Price: ₹{vwap_result['current_price']:.2f}")
    print(f"   Deviation: {vwap_result['deviation']:.2f}%")
    print(f"   Signal: {vwap_result['signal']}")
    
    # Test Keltner Channels
    print("\n4. Keltner Channels:")
    keltner_result = TechnicalIndicators.calculate_keltner_channels(prices, high, low)
    print(f"   Upper: ₹{keltner_result['upper']:.2f}")
    print(f"   Middle: ₹{keltner_result['middle']:.2f}")
    print(f"   Lower: ₹{keltner_result['lower']:.2f}")
    print(f"   Position: {keltner_result['position']}")
    print(f"   Signal: {keltner_result['signal']}")
    
    # Test Supertrend
    print("\n5. Supertrend:")
    supertrend_result = TechnicalIndicators.calculate_supertrend(prices, high, low)
    print(f"   Supertrend: ₹{supertrend_result['supertrend']:.2f}")
    print(f"   Direction: {supertrend_result['direction']}")
    print(f"   Trend: {supertrend_result['trend']}")
    print(f"   Signal: {supertrend_result['signal']}")
    
    # Test Signal Duration Prediction
    print("\n6. Duration Prediction:")
    
    # Create sample OHLCV DataFrame
    ohlcv_df = pd.DataFrame({
        'open': prices.shift(1).fillna(method='bfill'),
        'high': high,
        'low': low,
        'close': prices,
        'volume': volume
    })
    
    # Collect all indicators for duration prediction
    indicators = {
        "macd": macd_result,
        "rsi": rsi_result,
        "supertrend": supertrend_result
    }
    
    duration_pred = TechnicalIndicators.predict_signal_duration(indicators, ohlcv_df)
    print(f"   Estimated Duration: {duration_pred['estimated_minutes']} minutes")
    print(f"   Estimated Candles: {duration_pred['estimated_candles']}")
    print(f"   Confidence: {duration_pred['confidence'].upper()}")
    print(f"   Strength Trend: {duration_pred['strength_trend'].title()}")
    
    if duration_pred.get('key_levels'):
        print(f"   Key Levels:")
        print(f"     - Resistance: ₹{duration_pred['key_levels']['resistance']:.2f}")
        print(f"     - Support: ₹{duration_pred['key_levels']['support']:.2f}")
        print(f"     - Pivot: ₹{duration_pred['key_levels']['pivot']:.2f}")

if __name__ == "__main__":
    test_indicators()
7. Configuration Optimization
Finding Optimal Indicator Weights
python


# optimize_weights.py
import itertools
import numpy as np
from backtest_engine import BacktestEngine
from historical_data import DhanHistoricalData
import config

def optimize_indicator_weights():
    """Find optimal indicator weights through backtesting."""
    
    # Fetch historical data
    fetcher = DhanHistoricalData(
        config.DHAN_ACCESS_TOKEN_B64,
        config.DHAN_CLIENT_ID_B64
    )
    
    print("Fetching training data...")
    data = fetcher.fetch_data_in_chunks(
        "2025-08-01", "2025-08-20", timeframe="minute"
    )
    
    if data is None:
        print("Failed to fetch data")
        return
    
    # Generate weight combinations (must sum to 1.0)
    weight_options = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35]
    
    best_result = None
    best_weights = None
    best_return = -float('inf')
    
    tested_count = 0
    
    print("\nTesting weight combinations...")
    
    # Test different weight combinations
    for weights in itertools.product(weight_options, repeat=6):
        if abs(sum(weights) - 1.0) > 0.001:  # Skip if doesn't sum to 1
            continue
        
        weight_dict = {
            "macd": weights[0],
            "rsi": weights[1],
            "vwap": weights[2],
            "keltner": weights[3],
            "supertrend": weights[4],
            "impulse": weights[5]
        }
        
        # Run backtest with these weights
        backtest = BacktestEngine(initial_capital=1000000)
        results = backtest.run_backtest(
            data,
            weight_dict,
            config.MIN_DATA_POINTS
        )
        
        tested_count += 1
        
        # Check if this is the best so far
        total_return = results['total_return_pct']
        
        if total_return > best_return:
            best_return = total_return
            best_weights = weight_dict
            best_result = results
            
            print(f"New best found! Return: {total_return:.2f}%")
            print(f"Weights: {weight_dict}")
        
        # Progress update
        if tested_count % 10 == 0:
            print(f"Tested {tested_count} combinations...")
    
    # Print best results
    print("\n" + "="*60)
    print("OPTIMIZATION RESULTS")
    print("="*60)
    print(f"Best Return: {best_return:.2f}%")
    print(f"Best Sharpe Ratio: {best_result['sharpe_ratio']:.2f}")
    print(f"Win Rate: {best_result['win_rate']:.1f}%")
    print("\nOptimal Weights:")
    for indicator, weight in best_weights.items():
        print(f"  {indicator}: {weight:.2f}")
    
    # Save to file
    import json
    with open("optimal_weights.json", "w") as f:
        json.dump({
            "weights": best_weights,
            "performance": {
                "return": best_return,
                "sharpe_ratio": best_result['sharpe_ratio'],
                "win_rate": best_result['win_rate']
            }
        }, f, indent=2)
    
    print("\nResults saved to optimal_weights.json")

if __name__ == "__main__":
    optimize_indicator_weights()
8. Error Handling and Recovery
Handling Connection Issues
python


# connection_monitor.py
import time
import logging
from dhan_ws_client import DhanWebSocketClient
from telegram_bot import TelegramBot
import config

def run_with_recovery():
    """Run the system with automatic recovery from failures."""
    
    logger = logging.getLogger(__name__)
    max_failures = 5
    failure_count = 0
    
    telegram_bot = TelegramBot(
        config.TELEGRAM_BOT_TOKEN_B64,
        config.TELEGRAM_CHAT_ID
    )
    
    while failure_count < max_failures:
        try:
            # Create new client instance
            client = DhanWebSocketClient(
                config.DHAN_ACCESS_TOKEN_B64,
                config.DHAN_CLIENT_ID_B64,
                telegram_bot
            )
            
            # Connect
            logger.info("Attempting to connect...")
            client.connect()
            
            # Monitor connection
            while client.connected:
                time.sleep(30)
                
                # Health check
                if len(client.minute_ohlcv) > 0:
                    last_candle_time = client.minute_ohlcv.index[-1]
                    time_since_last = (pd.Timestamp.now() - last_candle_time).total_seconds()
                    
                    if time_since_last > 300:  # No data for 5 minutes
                        logger.warning("No new data for 5 minutes, reconnecting...")
                        client.disconnect()
                        break
            
            # Connection lost
            failure_count += 1
            logger.warning(f"Connection lost (attempt {failure_count}/{max_failures})")
            
            # Wait before retry
            wait_time = min(30 * failure_count, 300)
            time.sleep(wait_time)
            
        except KeyboardInterrupt:
            logger.info("Shutdown requested by user")
            break
            
        except Exception as e:
            logger.error(f"Unexpected error: {e}", exc_info=True)
            failure_count += 1
            time.sleep(60)
    
    if failure_count >= max_failures:
        telegram_bot.send_message(
            "❌ System stopped: Maximum failures reached\n"
            "Please check logs and restart manually"
        )

if __name__ == "__main__":
    from logging_setup import setup_logging
    setup_logging()
    run_with_recovery()
Common Commands Summary
bash


# Live trading
python main.py --mode live

# Backtest last week
python main.py --mode backtest --from-date 2025-08-16 --to-date 2025-08-23

# Fetch historical data
python main.py --mode fetch --from-date 2025-08-20 --to-date 2025-08-23

# Test indicators
python test_indicators.py

# Optimize weights
python optimize_weights.py

# Run with recovery
python connection_monitor.py
These examples demonstrate the complete functionality of the enhanced trading system, including signal accuracy metrics, duration predictions, and comprehensive alert information. The system provides clear, actionable insights without emojis while maintaining professional formatting.